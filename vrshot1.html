<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>A‑Frame Space Shooter – Quest 3</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Optional: text component polyfill for crisp HUD text on Quest -->
  <script src="https://unpkg.com/aframe-text-geometry-component@^0.5.1/dist/aframe-text-geometry-component.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
  </style>
</head>
<body>
  <a-scene renderer="colorManagement: true; antialias: true"
           background="color: #000"
           vr-mode-ui="enabled: true"
           webxr="optionalFeatures: local-floor, bounded-floor, hand-tracking">

    <!-- Lighting / sky -->
    <a-entity light="type: ambient; intensity: 0.5"></a-entity>
    <a-entity light="type: directional; intensity: 0.7" position="1 1 0"></a-entity>
    <a-sky color="#02030f"></a-sky>

    <!-- Stars backdrop -->
    <a-entity id="starfield" starfield></a-entity>

    <!-- Player rig: camera + hands -->
    <a-entity id="rig" position="0 1.6 0" player-move>
      <a-entity id="camera" camera look-controls></a-entity>
      <a-entity id="rightHand" oculus-touch-controls="hand: right" shooter raycaster="objects: .enemy; showLine: false"></a-entity>
      <a-entity id="leftHand"  oculus-touch-controls="hand: left"></a-entity>
    </a-entity>

    <!-- HUD (attached to camera) -->
    <a-entity id="hud" position="0 0 -1.2" rotation="0 0 0" 
              text="value: Score: 0 | HP: 100; align: center; color: #00e5ff; width: 2"
              geometry="primitive: plane; height: 0.12; width: 0.9"
              material="color: #000; opacity: 0.35"
              parent-to="#camera"></a-entity>

    <!-- Spawner + game manager -->
    <a-entity id="game" enemy-spawner="interval: 1600" game-manager></a-entity>

    <!-- Simple boundary grid for orientation -->
    <a-entity position="0 0 -4" grid></a-entity>

    <!-- ===== Components ===== -->
    <script>
      // Parent an entity to a target (useful for HUD following camera)
      AFRAME.registerComponent('parent-to', {
        schema: {default: ''},
        init() { const t = document.querySelector(this.data); if (t) t.appendChild(this.el); }
      });

      // Minimal starfield
      AFRAME.registerComponent('starfield', {
        init() {
          const stars = new THREE.Group();
          const geo = new THREE.SphereGeometry(0.02, 6, 6);
          const mat = new THREE.MeshBasicMaterial({color: 0xffffff});
          for (let i = 0; i < 1500; i++) {
            const m = new THREE.Mesh(geo, mat);
            const r = 60 + Math.random()*60;
            const theta = Math.random()*Math.PI*2;
            const phi = Math.acos(2*Math.random()-1);
            m.position.set(
              r*Math.sin(phi)*Math.cos(theta),
              r*Math.sin(phi)*Math.sin(theta),
              r*Math.cos(phi)
            );
            stars.add(m);
          }
          this.el.setObject3D('mesh', stars);
        }
      });

      // Simple ground grid for orientation
      AFRAME.registerComponent('grid', {
        init() {
          const size = 20, div = 20;
          const grid = new THREE.GridHelper(size, div, 0x113355, 0x112233);
          grid.position.y = -1.6;
          this.el.setObject3D('mesh', grid);
        }
      });

      // Player thumbstick locomotion (left stick). Forward/back + strafe.
      AFRAME.registerComponent('player-move', {
        schema: {speed: {default: 2.0}},
        init() {
          this.rig = this.el; // rig entity
          this.left = document.querySelector('#leftHand');
          this.dir = new THREE.Vector3();
          this.tmp = new THREE.Vector3();
          this.camera = document.querySelector('#camera');
          this.axis = [0,0];
          if (this.left) {
            this.left.addEventListener('axismove', e => {
              // e.detail.axis = [x, y, x2, y2] for Oculus; we take first stick
              this.axis = [e.detail.axis[0], e.detail.axis[1]];
            });
          }
        },
        tick(time, dt) {
          const s = (dt/1000) * this.data.speed; // meters per second
          if (!this.camera || (Math.abs(this.axis[0]) < 0.05 && Math.abs(this.axis[1]) < 0.05)) return;
          // Move relative to camera forward/right (Y-up)
          const camObj = this.camera.object3D;
          camObj.getWorldDirection(this.dir); // forward
          this.dir.y = 0; this.dir.normalize();
          const right = this.tmp.set(this.dir.z, 0, -this.dir.x); // perpendicular on XZ
          const move = this.tmp.set(0,0,0)
            .addScaledVector(this.dir, -this.axis[1] * s)
            .addScaledVector(right, this.axis[0] * s);
          this.rig.object3D.position.add(move);
        }
      });

      // Shooter component (right trigger fires)
      AFRAME.registerComponent('shooter', {
        init() {
          this.cooldown = 0;
          this.el.addEventListener('triggerdown', () => this.tryShoot());
          // Also map A button as alternative
          this.el.addEventListener('abuttondown', () => this.tryShoot());
        },
        tick(time, dt){ if (this.cooldown > 0) this.cooldown -= dt; },
        tryShoot() {
          if (this.cooldown > 0) return;
          this.cooldown = 120; // ms
          const hand = this.el.object3D;
          const bullet = document.createElement('a-entity');
          bullet.setAttribute('geometry', 'primitive: sphere; radius: 0.03');
          bullet.setAttribute('material', 'color: #00ffcc; emissive: #00ffcc; emissiveIntensity: 0.9');
          bullet.setAttribute('bullet', 'speed: 20; lifetime: 1500');
          // position & direction
          const pos = new THREE.Vector3();
          const dir = new THREE.Vector3();
          hand.getWorldPosition(pos);
          hand.getWorldDirection(dir);
          pos.addScaledVector(dir, 0.15); // start a bit in front of hand
          bullet.object3D.position.copy(pos);
          bullet.object3D.quaternion.copy(hand.getWorldQuaternion(new THREE.Quaternion()));
          bullet.setAttribute('velocity-forward', 'speed: 20');
          this.el.sceneEl.appendChild(bullet);
          // muzzle flash
          const flash = document.createElement('a-entity');
          flash.setAttribute('geometry', 'primitive: sphere; radius: 0.05');
          flash.setAttribute('material', 'color: #88fff6; opacity: 0.7');
          flash.object3D.position.copy(pos);
          this.el.sceneEl.appendChild(flash);
          setTimeout(()=>flash.remove(), 60);
        }
      });

      // Move forward in the object's -Z each tick (uses current world orientation)
      AFRAME.registerComponent('velocity-forward', {
        schema: {speed: {default: 10}},
        tick(time, dt) {
          const s = (dt/1000) * this.data.speed;
          const dir = new THREE.Vector3();
          this.el.object3D.getWorldDirection(dir);
          this.el.object3D.position.addScaledVector(dir, s);
        }
      });

      // Bullet lifetime + enemy collision
      AFRAME.registerComponent('bullet', {
        schema: {lifetime: {default: 1200}, speed: {default: 20}},
        init(){ this.age = 0; },
        tick(time, dt){
          this.age += dt;
          if (this.age > this.data.lifetime) { this.el.remove(); return; }
          // Collision with enemies (distance check)
          const enemies = document.querySelectorAll('.enemy');
          const bp = this.el.object3D.position;
          for (let i=0; i<enemies.length; i++){
            const ep = enemies[i].object3D.position;
            if (bp.distanceTo(ep) < 0.3){
              enemies[i].emit('hit');
              this.el.remove();
              break;
            }
          }
        }
      });

      // Enemy behavior
      AFRAME.registerComponent('enemy', {
        schema: {speed: {default: 1.2}, hp: {default: 1}},
        init(){
          this.rig = document.querySelector('#rig').object3D;
          this.dir = new THREE.Vector3();
          this.dead = false;
          this.onHit = () => {
            if (this.dead) return;
            this.data.hp -= 1;
            if (this.data.hp <= 0) {
              this.dead = true;
              // explosion
              const boom = document.createElement('a-entity');
              boom.setAttribute('geometry', 'primitive: sphere; radius: 0.4');
              boom.setAttribute('material', 'color: #ffda6b; emissive: #ff8800; emissiveIntensity: 1; opacity: 0.8');
              boom.object3D.position.copy(this.el.object3D.position);
              this.el.sceneEl.appendChild(boom);
              setTimeout(()=>boom.remove(), 120);
              this.el.remove();
              document.querySelector('#game').components['game-manager'].addScore(10);
            }
          }
          this.el.addEventListener('hit', this.onHit);
        },
        remove(){ this.el.removeEventListener('hit', this.onHit); },
        tick(time, dt){
          if (this.dead) return;
          const s = (dt/1000) * this.data.speed;
          const p = this.el.object3D.position;
          const target = this.rig.position;
          this.dir.copy(target).sub(p).setY(0).normalize();
          p.addScaledVector(this.dir, s);
          // If too close -> damage player and remove
          if (p.distanceTo(target) < 0.6){
            document.querySelector('#game').components['game-manager'].damage(10);
            this.el.remove();
          }
        }
      });

      // Enemy spawner
      AFRAME.registerComponent('enemy-spawner', {
        schema: {interval: {default: 1500}},
        init(){ this.t = 0; },
        tick(time, dt){
          this.t += dt;
          if (this.t >= this.data.interval){
            this.t = 0;
            const e = document.createElement('a-entity');
            e.setAttribute('class', 'enemy');
            e.setAttribute('geometry', 'primitive: icosahedron; radius: 0.25; detail: 1');
            e.setAttribute('material', 'color: #ff476f; metalness: 0.1; roughness: 0.4; emissive: #ff2a4f; emissiveIntensity: 0.3');
            e.setAttribute('enemy', 'speed: ' + (0.8 + Math.random()*1.2));
            // Spawn in a ring around player (3.5–7m) at random angle
            const rig = document.querySelector('#rig').object3D.position;
            const r = 3.5 + Math.random()*3.5;
            const a = Math.random()*Math.PI*2;
            e.object3D.position.set(rig.x + Math.cos(a)*r, rig.y, rig.z + Math.sin(a)*r);
            this.el.sceneEl.appendChild(e);
          }
        }
      });

      // Game manager: score + health + HUD updates + restart
      AFRAME.registerComponent('game-manager', {
        init(){
          this.score = 0; this.hp = 100;
          this.hud = document.querySelector('#hud');
          this.updateHUD();
        },
        addScore(n){ this.score += n; this.updateHUD(); },
        damage(n){
          this.hp = Math.max(0, this.hp - n);
          this.updateHUD();
          if (this.hp === 0) this.gameOver();
        },
        updateHUD(){
          this.hud.setAttribute('text', 'value', `Score: ${this.score} | HP: ${this.hp}`);
        },
        gameOver(){
          // Clear remaining enemies
          document.querySelectorAll('.enemy').forEach(e=>e.remove());
          const msg = document.createElement('a-entity');
          msg.setAttribute('position', '0 0 -1.6');
          msg.setAttribute('text', 'value: GAME OVER – Press A or trigger to restart; align: center; color: #ff476f; width: 2.4');
          msg.setAttribute('parent-to', '#camera');
          this.hud.parentElement.appendChild(msg);
          const restart = () => { msg.remove(); this.score = 0; this.hp = 100; this.updateHUD(); };
          document.querySelector('#rightHand').addEventListener('abuttondown', restart, {once: true});
          document.querySelector('#rightHand').addEventListener('triggerdown', restart, {once: true});
        }
      });
    </script>
  </a-scene>
</body>
</html>
